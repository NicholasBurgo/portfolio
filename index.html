<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nicholas Burgo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/js/all.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary-blue: #4fc3f7;
        --secondary-blue: #2d3748;
        --accent-color: #4fc3f7;
        --text-primary: #f3f4f6;
        --text-secondary: #cbd5e1;
        --text-muted: #9ca3af;
        --glass-bg: rgba(255, 255, 255, 0.05);
        --glass-border: rgba(79, 195, 247, 0.2);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Inter', sans-serif;
        background: linear-gradient(to bottom, #0a0f1a, #12161d);
        color: var(--text-primary);
        min-height: 100vh;
        position: relative;
        overflow-x: hidden;
        line-height: 1.6;
      }
      
      /* Enhanced background */
      body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
          radial-gradient(ellipse at 30% 40%, rgba(79, 195, 247, 0.08) 0%, transparent 70%),
          radial-gradient(ellipse at 70% 60%, rgba(79, 195, 247, 0.05) 0%, transparent 60%);
        z-index: -1;
        animation: nebulaShift 20s ease-in-out infinite;
      }
      
      @keyframes nebulaShift {
        0%, 100% {
          opacity: 0.6;
          transform: scale(1);
        }
        50% {
          opacity: 0.8;
          transform: scale(1.02);
        }
      }
      
      html {
        scroll-behavior: smooth;
      }

      /* Typography */
      .text-gradient {
        background: linear-gradient(135deg, #4fc3f7 0%, #ffffff 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
      }
      
      @keyframes fadeInDown {
        from {
          opacity: 0;
          transform: translateY(-30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes scaleIn {
        from {
          transform: scale(0.9);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes spiralIn {
        0% {
          opacity: 0;
          transform: scale(0.7) rotate(-360deg) translateY(80px);
        }
        60% {
          opacity: 1;
          transform: scale(1.05) rotate(10deg) translateY(-5px);
        }
        80% {
          transform: scale(0.98) rotate(-3deg) translateY(3px);
        }
        100% {
          opacity: 1;
          transform: scale(1) rotate(0deg) translateY(0);
        }
      }

      .spiral-hidden {
        opacity: 0;
        transform: scale(0.7) rotate(-360deg) translateY(80px);
        transition: none;
      }

      .spiral-in {
        animation: spiralIn 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards;
      }

      .animate-bounce-slow {
        animation: bounce-slow 3s infinite;
      }

      .animate-fade-in-down {
        animation: fadeInDown 0.8s ease-out forwards;
      }

      .animate-fade-in-up {
        animation: fadeInUp 0.8s ease-out forwards;
      }

      .animate-fade-in {
        animation: fadeIn 1s ease-out forwards;
      }

      .animate-scale-in {
        animation: scaleIn 0.6s ease-out forwards;
      }

      @keyframes bounce-slow {
        0%, 100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(8px);
        }
      }

      /* Navigation styles */
      nav {
        background: rgba(255, 255, 255, 0.05) !important;
        backdrop-filter: blur(10px) !important;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      nav a {
        position: relative;
        transition: all 0.3s ease;
      }

      nav a::after {
        content: '';
        position: absolute;
        bottom: -4px;
        left: 50%;
        width: 0;
        height: 2px;
        background: #4fc3f7;
        transition: all 0.3s ease;
        transform: translateX(-50%);
      }

      nav a:hover::after,
      nav a.active::after {
        width: 100%;
      }

      nav a.active {
        color: #4fc3f7 !important;
      }
      
      .section-bg {
        position: relative;
        overflow: hidden;
      }

      .section-bg::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        opacity: 0;
        z-index: 0;
        transition: opacity 0.8s ease;
      }

      .section-bg > * {
        position: relative;
        z-index: 1;
      }
      
      .home-bg::before {
        background-image: url('images/Galaxy.jpg');
      }

      .projects-bg::before {
        background-image: url('images/coding-bg.jpg');
      }

      .about-bg::before {
        background-image: url('images/tech-bg.jpg');
      }
      
      .section-bg.active::before {
        opacity: 0.3;
      }

      .projects-bg.active::before {
        opacity: 0.2;
      }

      .about-bg.active::before {
        opacity: 0.15;
      }
      
      .project-card {
        transition: all 0.3s ease;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(79, 195, 247, 0.2);
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      .project-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(79, 195, 247, 0.4);
      }

      .project-card img {
        transition: transform 0.3s ease;
      }

      .project-card:hover img {
        transform: scale(1.05);
      }

      #follower {
        position: fixed;
        width: 12px;
        height: 12px;
        background-color: rgba(79,195,247, 0.4); 
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%) scale(1);
        transition: transform 0.15s ease-out, background-color 0.2s ease-out;
        backdrop-filter: blur(3px);
        box-shadow: 0 0 6px rgba(79,195,247, 0.3);
        z-index: 100;
      }

      #name {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Inter', sans-serif;
        font-size: 3rem;
        font-weight: 800;
        color: #ffffff;
        cursor: default;
        text-shadow: 0 4px 24px rgba(0,0,0,0.4);
      }

      #name span {
        display: inline-block;
        transition: transform 0.2s ease-out;
        pointer-events: none;
      }

      .subtitle {
        font-family: 'Inter', sans-serif;
        font-weight: 400;
        font-size: 1.1rem;
        letter-spacing: 0.25em;
        color: rgba(180, 210, 255, 0.85);
        text-shadow: 0 2px 8px rgba(44, 130, 201, 0.18);
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
        transition: color 0.3s;
        text-transform: uppercase;
        animation: fadeInUp 1.2s 0.3s both;
      }

      /* Glitch effect */
      @keyframes glitchIn {
        0% {
          opacity: 0;
        }
        20% {
          opacity: 0.3;
        }
        40% {
          opacity: 0.7;
        }
        60% {
          opacity: 0.9;
        }
        100% {
          opacity: 1;
        }
      }

      @keyframes glitchOut {
        0% {
          opacity: 1;
        }
        30% {
          opacity: 0.8;
        }
        60% {
          opacity: 0.4;
        }
        100% {
          opacity: 0;
        }
      }

      .glitch-in {
        animation: glitchIn 0.3s ease-out forwards;
      }

      .glitch-out {
        animation: glitchOut 0.25s ease-in forwards;
      }

      /* Enhanced floating elements */
      .floating {
        animation: float 4s ease-in-out infinite;
      }

      .floating:nth-child(2) { animation-delay: 1s; }
      .floating:nth-child(3) { animation-delay: 2s; }

      @keyframes float {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-5px); }
      }

      /* Mobile responsive styles */
      @media (max-width: 768px) {
        /* Mobile navigation */
        nav {
          min-width: 90vw !important;
          max-width: 95vw !important;
          padding: 8px 12px !important;
          gap: 4px !important;
        }
        nav .flex {
          gap: 12px !important;
        }
        nav a {
          font-size: 12px !important;
          padding: 4px 8px;
        }
        
        /* Mobile home section */
        #home {
          padding: 16px 8px !important;
          padding-top: 80px !important;
        }
        
        /* Mobile name styling */
        #name span {
          font-size: 2rem !important;
        }
        .subtitle {
          font-size: 0.7rem !important;
          letter-spacing: 0.05em !important;
          margin-top: 1rem !important;
        }
        
        /* Mobile wave text */
        .wave-text {
          font-size: 14px !important;
          margin-bottom: 8px !important;
        }
        
        /* Mobile modals */
        #project-modal {
          margin: 16px !important;
          padding: 16px !important;
          max-height: 85vh !important;
        }
        #project-modal-body {
          padding-right: 0 !important;
        }
        
        /* Mobile bottom section */
        .absolute.bottom-8 {
          bottom: 32px !important;
        }
      }

      @media (max-width: 480px) {
        /* Extra small mobile adjustments */
        nav a {
          font-size: 11px !important;
        }
        nav .flex {
          gap: 8px !important;
        }
        
        #name span {
          font-size: 1.5rem !important;
        }
        .subtitle {
          font-size: 0.6rem !important;
        }
        .wave-text {
          font-size: 12px !important;
        }
      }

      /* Wave animation effects */
      .wave-text {
        position: relative;
      }

      .wave-text span {
        display: inline-block;
        transition: all 0.3s ease;
      }

      .wave-animate span {
        animation: wave 3.5s ease-in-out;
      }

      @keyframes wave {
        0%, 100% {
          transform: translateY(0);
        }
        7% {
          transform: translateY(-8px);
        }
        14% {
          transform: translateY(0);
        }
      }

      .wave-animate span:nth-child(1) { animation-delay: 0.15s; }
      .wave-animate span:nth-child(2) { animation-delay: 0.3s; }
      .wave-animate span:nth-child(3) { animation-delay: 0.45s; }
      .wave-animate span:nth-child(4) { animation-delay: 0.6s; }
      .wave-animate span:nth-child(5) { animation-delay: 0.75s; }
      .wave-animate span:nth-child(6) { animation-delay: 0.9s; }
      .wave-animate span:nth-child(7) { animation-delay: 1.05s; }
      .wave-animate span:nth-child(8) { animation-delay: 1.2s; }
      .wave-animate span:nth-child(9) { animation-delay: 1.35s; }
      .wave-animate span:nth-child(10) { animation-delay: 1.5s; }
      .wave-animate span:nth-child(11) { animation-delay: 1.65s; }
      .wave-animate span:nth-child(12) { animation-delay: 1.8s; }
      .wave-animate span:nth-child(13) { animation-delay: 1.95s; }
      .wave-animate span:nth-child(14) { animation-delay: 2.1s; }

      /* Enhanced Go to Projects hover effects */
      .go-to-projects-link {
        transition: all 0.3s ease;
      }

      .go-to-projects-link:hover {
        transform: translateY(-2px);
      }

      .go-to-projects-link:hover .wave-text {
        color: #4fc3f7 !important;
        text-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
      }

      /* Image viewer styles */
      .image-viewer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
      }

      .image-viewer.active {
        opacity: 1;
        visibility: visible;
      }

      .image-viewer img {
        max-width: 90%;
        max-height: 90%;
        object-fit: contain;
        border-radius: 8px;
      }

      /* Gallery styles */
      .image-gallery {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin: 1rem 0;
      }

      .gallery-image {
        width: 100%;
        height: 150px;
        object-fit: cover;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.3s ease;
      }

      .gallery-image:hover {
        transform: scale(1.05);
      }
    </style>
  </head>
  <body class="relative overflow-x-hidden">
    <header class="fixed top-0 left-0 w-full z-50 px-6 py-4 flex items-center justify-center">
      <nav class="flex items-center justify-center gap-8 text-md font-bold text-white/90 bg-white/10 backdrop-filter blur-20px border border-white/20 rounded-full px-8 py-3 shadow-xl min-w-[340px] w-auto max-w-2xl">
        <div class="flex gap-8">
          <a href="index.html" class="text-blue-300 scale-105">Home</a>
          <a href="projects.html" class="hover:text-blue-300 transition-all duration-300 hover:scale-105">Projects</a>
          <a href="about.html" class="hover:text-blue-300 transition-all duration-300 hover:scale-105">About</a>
          <a href="contact.html" class="hover:text-blue-300 transition-all duration-300 hover:scale-105">Contact</a>
        </div>
      </nav>
    </header>

    <section id="home" class="section-bg home-bg min-h-screen flex flex-col items-center justify-center px-4 text-center pt-26">
      <!-- Particle background canvas -->
      <canvas id="particles-bg" style="position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;pointer-events:none;"></canvas>
      <div class="relative z-10 animate-scale-in">
        <h2 class="text-4xl sm:text-6xl md:text-8xl lg:text-9xl font-extrabold tracking-tight text-white mb-14 whitespace-nowrap">
          <div id="name" class="flex justify-center gap-0">
            <!-- Name letters will be typed in with animation -->
          </div>
        </h2>
        <span class="mx-4"></span>
        <p class="mt-8 text-base sm:text-lg text-white/80 tracking-widest uppercase">
          <span id="typing-subtitle" class="subtitle flex justify-center gap-0">
            <!-- Typing text will be inserted here dynamically -->
          </span>
        </p>
      </div>
      <div class="absolute bottom-8 left-1/2 -translate-x-1/2 flex flex-col items-center w-full z-20">
        <a href="projects.html" class="relative flex flex-col items-center group go-to-projects-link">
          <span class="wave-text mb-2 text-white/80 text-lg tracking-widest z-10 transition-all duration-300 group-hover:scale-105 group-hover:text-blue-300">
            <span>G</span><span>o</span><span>&nbsp;</span><span>t</span><span>o</span><span>&nbsp;</span><span>P</span><span>r</span><span>o</span><span>j</span><span>e</span><span>c</span><span>t</span><span>s</span>
          </span>
        </a>
      </div>
    </section>

    <div id="follower"></div>

    <div id="project-modal-overlay" class="fixed inset-0 bg-black/80 z-50 flex items-center justify-center hidden opacity-0 invisible transition-all duration-300">
      <div id="project-modal" class="bg-[#17243b] rounded-3xl shadow-xl border-2 border-[#4fc3f7] max-w-4xl w-full mx-4 p-7 pt-5 relative max-h-[90vh] overflow-y-auto"
          onclick="event.stopPropagation();">
        <button onclick="closeProjectModal()"
                class="absolute top-4 right-5 text-[#b1c9e7] hover:text-[#4fc3f7] p-2 text-xl z-10">
          <i class="fa-solid fa-xmark"></i>
        </button>
        <div id="project-modal-body" class="flex flex-col gap-5 pr-8"></div>
      </div>
    </div>

    <div id="image-viewer" class="image-viewer" onclick="closeImageViewer()">
      <button onclick="closeImageViewer()" class="absolute top-4 right-4 text-white text-2xl z-10">
        <i class="fa-solid fa-xmark"></i>
      </button>
      <img id="viewer-image" src="" alt="Full size image" />
    </div>

    <script>
      const projectData = [
        {
          title: "Fable Market",
          tech: ["React", "FastAPI", "PostgreSQL"],
          desc: "A comprehensive book marketplace platform with features for purchasing books, leaving reviews, and creating personalized book lists with advanced search functionality.",
          longDesc: `<b>Role:</b> Team Leader, Full Stack Developer<br>
            <b>Problem:</b> Need for a comprehensive platform where users can discover, purchase, and review books with personalized features.<br>
            <b>Solution:</b> Developed a full-featured book marketplace with advanced search capabilities, user reviews, and personalized book lists to enhance the book discovery experience.<br>
            <b>Key Features:</b> Advanced search functionality by title, author, and genre using optimized string comparison queries, integrated database management for efficient data operations, user review system, and personalized book list creation with data integrity enforcement.`,
          images: [
            "images/fableMarket2.png",
            "images/fable-search.jpg",
            "images/fable-search2.jpg",
          ],
          links: [],
        },
        {
          title: "Car Dealership Database",
          tech: ["SQL", "Database Management"],
          desc: "Architected a comprehensive 5-table relational database system for car-rental operations with full ER-diagram modeling and SQL implementation.",
          longDesc: `<b>Role:</b> Team Leader, Database Architect<br>
            <b>Problem:</b> Need for a robust relational database system to manage complex car-rental operations with proper data integrity.<br>
            <b>Solution:</b> Designed and implemented a normalized 5-table database schema following 3NF principles with comprehensive ER-diagram modeling and SQL DDL implementation.<br>
            <b>Key Features:</b> Fully annotated ER-diagram with min/max participation constraints, SQL DDL with primary/foreign-key enforcement and cascading rules, seeded database with 100+ realistic records using bulk-load scripts, traceable BO&R documentation linking business requirements to database structure, and FK-mapping matrix for team collaboration.`,
          images: [
          ],
          links: [
            {
              type: "github",
              url: "https://github.com/NicholasBurgo/Car-Dealership",
            },
          ],
        },
        {
          title: "CityRift VR",
          tech: ["C#", "Unity", "Blender"],
          desc: "End-to-end virtual reality sandbox built in Unity combining first-person weapon mechanics with AI-driven open world environments.",
          longDesc: `<b>Role:</b> Game Developer, VR Specialist<br>
            <b>Problem:</b> Creating an immersive VR experience that combines realistic weapon mechanics with intelligent AI behavior in an open world.<br>
            <b>Solution:</b> Built a comprehensive VR sandbox using Unity with C# comprising 90% of the codebase, featuring advanced VR-rig locomotion, ray-cast gun mechanics, and autonomous AI systems.<br>
            <b>Key Features:</b> VR-rig locomotion system with comfortable movement, ray-cast gun logic with realistic weapon mechanics, enemy/pedestrian state machines with reactive AI behavior, autonomous traffic system with lane-following rules, explorable streetscape environment, multiplatform builds with IL2CPP + Burst optimization, and comprehensive version control with clean collaboration setup.`,
          images: [
            "images/vr-shooter2.jpg",
          ],
          links: [
            {
              type: "github",
              url: "https://github.com/NicholasBurgo/VrShooter",
            },
          ],
        },
        {
          title: "Lua Multiplayer Networking",
          tech: ["Lua", "Love Engine"],
          desc: "Engaging local multiplayer mini-games built with Lua using host-client architecture for seamless real-time player interactions.",
          longDesc: `<b>Role:</b> Game Developer, Network Programmer<br>
            <b>Problem:</b> Creating engaging multiplayer experiences with real-time communication and seamless player interactions.<br>
            <b>Solution:</b> Developed local multiplayer mini-games using Lua and Love Engine with robust host-client networking architecture for dynamic player interactions.<br>
            <b>Key Features:</b> Host-client architecture for reliable multiplayer connections, real-time communication system enabling dynamic player interactions, multiple mini-game modes with engaging gameplay mechanics, and optimized networking code for smooth multiplayer experience.`,
          images: [
            "images/lua-multiplayer2.jpg",
            "images/lua-networking.jpg",
            "images/lua-games.jpg",
            "images/lua-games2.jpg"
          ],
          links: [],
        },
        {
          title: "Portfolio Template",
          tech: ["HTML", "CSS", "JavaScript"],
          desc: "A clean, single-page portfolio template with dark theme and interactive animations - perfect for students and developers who want a professional, customizable portfolio.",
          longDesc: `<b>Role:</b> Frontend Developer, UI/UX Designer<br>
            <b>Problem:</b> Need for a professional portfolio template that's better than basic online templates, with cool animations and easy customization for students.<br>
            <b>Solution:</b> Created a single-page portfolio template with dark theme, interactive hover effects, and a simple configuration system for easy personalization.<br>
            <b>Key Features:</b> Single-page design with dark theme, interactive name hover effects, project showcase with modal system, about me section with skills, contact information, easy-to-use configuration object, Tailwind CSS styling, Font Awesome icons, and GitHub Pages deployment ready.`,
          images: [
            "images/portfolio-template-1.jpg",
            "images/portfolio-template-2.jpg",
            "images/portfolio-template-3.jpg"
          ],
          links: [
            {
              type: "github",
              url: "https://github.com/NicholasBurgo/portfolio_Template",
            },
            {
              type: "demo",
              url: "https://nicholasburgo.github.io/portfolio_Template/",
            },
          ],
        },
      ];

      function smoothScrollTo(elementId) {
        const element = document.getElementById(elementId);
        if (element) {
          element.scrollIntoView({
            behavior: 'smooth',
            block: 'start'
          });
        }
      }

      function closeProjectModal() {
        const overlay = document.getElementById("project-modal-overlay");
        overlay.classList.add("hidden", "opacity-0", "invisible");
        document.body.style.overflow = "";
      }
      
      function openProjectModal(idx) {
        const overlay = document.getElementById('project-modal-overlay');
        const body = document.getElementById('project-modal-body');
        const data = projectData[idx];
        if (!body) return;

        const techHTML = data.tech
              .map(t => `<span class="inline-block px-3 py-1 bg-blue-800 rounded-full text-xs mr-2 mb-1">${t}</span>`)
              .join('');

        const linksHTML = data.links
              .map(link =>
                link.type === 'github'
                  ? `<a href="${link.url}" target="_blank"
                        class="inline-flex items-center px-4 py-2 border border-blue-400 text-blue-400 rounded-full hover:bg-blue-600 hover:text-white transition">
                      <i class="fa-brands fa-github mr-2"></i> GitHub
                    </a>`
                  : '')
              .join('');

        const imagesHTML = data.images && data.images.length > 0
          ? `<div class="image-gallery">
               ${data.images.map(img => 
                 `<img src="${img}" alt="${data.title} screenshot" class="gallery-image" onclick="openImageViewer('${img}')" />`
               ).join('')}
             </div>`
          : '';

        body.innerHTML = `
            <h3 class="text-2xl font-bold mb-3">${data.title}</h3>
            <div class="mb-3">${techHTML}</div>
            <p class="mb-3 text-sm text-white/80">${data.desc}</p>
            ${imagesHTML}
            <p class="mb-4 text-white/60">${data.longDesc}</p>
            <div class="flex gap-3">${linksHTML}</div>
        `;

        overlay.classList.remove('hidden', 'opacity-0', 'invisible');
        document.body.style.overflow = 'hidden';
      }
      document.addEventListener('mousemove', function(e) {
        const follower = document.getElementById('follower');
        follower.style.left = `${e.clientX}px`;
        follower.style.top = `${e.clientY}px`;
      });

      function openImageViewer(imageSrc) {
        const viewer = document.getElementById('image-viewer');
        const image = document.getElementById('viewer-image');
        image.src = imageSrc;
        viewer.classList.add('active');
        document.body.style.overflow = 'hidden';
      }

      function closeImageViewer() {
        const viewer = document.getElementById('image-viewer');
        viewer.classList.remove('active');
        document.body.style.overflow = '';
      }

      document.getElementById('project-modal-overlay').addEventListener('click', function(e) {
        if (e.target === this) {
          closeProjectModal();
        }
      });

      function updateActiveBackground() {
        const sections = document.querySelectorAll('.section-bg');
        const windowHeight = window.innerHeight;
        const scrollY = window.scrollY;
        
        sections.forEach(section => {
          const rect = section.getBoundingClientRect();
          const sectionTop = scrollY + rect.top;
          const sectionBottom = sectionTop + rect.height;
          const viewportCenter = scrollY + windowHeight / 2;
          
          if (viewportCenter >= sectionTop && viewportCenter < sectionBottom) {
            section.classList.add('active');
          } else {
            section.classList.remove('active');
          }
        });
      }

      window.addEventListener('scroll', updateActiveBackground);
      window.addEventListener('load', updateActiveBackground);
      
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          closeProjectModal();
          closeImageViewer();
        }
      });
    // Name glitch animation
    let nameLetters = [];
    let subtitleReady = false;
    let nameWrapper = null;
    
    function initializeName() {
      const nameElement = document.getElementById('name');
      const fullName = 'NICHOLAS BURGO';
      
      // Clear and create wrapper
      nameElement.innerHTML = '';
      nameWrapper = document.createElement('div');
      nameWrapper.style.display = 'inline-flex';
      nameWrapper.style.gap = '0';
      
      fullName.split('').forEach((char, index) => {
        const span = document.createElement('span');
        span.className = 'text-4xl sm:text-5xl md:text-[5rem]';
        
        const letterSpan = document.createElement('span');
        if (char === ' ') {
          letterSpan.innerHTML = '&nbsp;';
          letterSpan.classList.add('mx-2');
        } else {
          letterSpan.textContent = char;
        }
        
        letterSpan.style.display = 'inline-block';
        letterSpan.style.transition = 'transform 0.2s ease-out';
        
        span.appendChild(letterSpan);
        nameWrapper.appendChild(span);
        nameLetters.push(letterSpan);
      });
      
      nameElement.appendChild(nameWrapper);
    }
    
    function glitchInName() {
      // Trigger glitch in animation
      nameWrapper.classList.add('glitch-in');
      
      // After animation completes, signal subtitle to start
      setTimeout(() => {
        subtitleReady = true;
      }, 400); // Match glitchIn animation duration plus a bit
    }
    
    // Mouse-over effect for name
    document.addEventListener('mousemove', (e) => {
      nameLetters.forEach(letter => {
        const rect = letter.getBoundingClientRect();
        const letterX = rect.left + rect.width / 2;
        const letterY = rect.top + rect.height / 2;

        const distX = e.clientX - letterX;
        const distY = e.clientY - letterY;
        const distance = Math.sqrt(distX ** 2 + distY ** 2);
        
        if (distance < 80) {
          const angle = Math.atan2(distY, distX);
          const offset = (80 - distance) / 3;
          letter.style.transform = `translate(${-Math.cos(angle) * offset}px, ${-Math.sin(angle) * offset}px)`;
        } else {
          letter.style.transform = 'translate(0, 0)';
        }
      });
    });
    
    // Start name glitch on page load
    initializeName();
    setTimeout(() => glitchInName(), 500); // Start after 500ms

    // Staggered slide-in-from-corner animation for project cards
    function animateProjectCardsCorner() {
      const cards = document.querySelectorAll('.project-card');
      cards.forEach((card, i) => {
        setTimeout(() => {
          card.classList.remove('corner-hidden');
          card.classList.add('corner-in');
        }, 250 * i);
      });
    }
    // Use Intersection Observer to trigger when projects section is in view
    const projectsSection = document.getElementById('projects');
    let cornerAnimated = false;
    if (projectsSection) {
      const observer = new window.IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !cornerAnimated) {
            animateProjectCardsCorner();
            cornerAnimated = true;
          }
        });
      }, { threshold: 0.3 });
      observer.observe(projectsSection);
    }

    // Gravity Well Particle System for home section
    (function() {
      const canvas = document.getElementById('particles-bg');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      let width = 0, height = 0, cx = 0, cy = 0;
      
      // Gravity well properties
      let gravityWell = {
        x: 0,
        y: 0,
        radiusX: 350, // Oval width (increased to cover full name)
        radiusY: 70,  // Oval height (increased to cover full name)
        strength: 0.01,
        eventHorizonX: 350, // Destruction zone width
        eventHorizonY: 70   // Destruction zone height
      };
      
      function resize() {
        const section = document.getElementById('home');
        width = section.offsetWidth;
        height = section.offsetHeight;
        canvas.width = width;
        canvas.height = height;
        cx = width / 2;
        cy = height / 2;
        
        // Update gravity well position to center (where name is)
        gravityWell.x = cx;
        gravityWell.y = cy;
      }
      window.addEventListener('resize', resize);
      resize();
      
      // Enhanced 3D Particle definition
      const PARTICLE_COUNT = 120; // Higher count for constant stream from all sides
      const particles = [];
      const destroyedParticles = [];
      
      // Code bubbles that follow particles
      const CODE_BUBBLE_COUNT = 15; // More bubbles for better coverage
      const codeBubbles = [];
      const codeSymbols = ['()', '{}', '[]', '<>'];
      // Technologies from your actual projects
      const codeTechs = ['React', 'FastAPI', 'PostgreSQL', 'C#', 'Unity', 'Blender', 
                         'Lua', 'HTML', 'CSS', 'JavaScript', 'SQL'];
      
      function randomBetween(a, b) { return a + Math.random() * (b - a); }
      
      function resetCodeBubble(bubble, index) {
        // Evenly space bubbles around the screen for less clutter
        const totalBubbles = CODE_BUBBLE_COUNT;
        const angleStep = (2 * Math.PI) / totalBubbles;
        const angle = angleStep * index + Math.random() * angleStep * 0.3; // Small randomness
        
        // Spawn at consistent distance with slight variation
        const spawnDistance = Math.max(width, height) * (0.45 + Math.random() * 0.1);
        
        bubble.x = Math.cos(angle) * spawnDistance;
        bubble.y = Math.sin(angle) * spawnDistance;
        bubble.z = randomBetween(0.8, 1.2); // Consistent depth
        
        // Use actual project technologies (40% symbols, 60% techs)
        const useSymbol = Math.random() < 0.4;
        bubble.text = useSymbol ? 
          codeSymbols[Math.floor(Math.random() * codeSymbols.length)] :
          codeTechs[Math.floor(Math.random() * codeTechs.length)];
        
        bubble.size = randomBetween(25, 32);
        bubble.opacity = randomBetween(0.25, 0.45); // More faded/subtle
        
        // Same velocity as particles for following effect
        const speed = randomBetween(0.3, 0.6); // Exact same speed as particles
        const angleToCenter = Math.atan2(-bubble.y, -bubble.x);
        const tangentialAngle = angleToCenter + Math.PI / 2;
        
        bubble.vx = Math.cos(angleToCenter) * speed * 0.35 + Math.cos(tangentialAngle) * speed * 0.65;
        bubble.vy = Math.sin(angleToCenter) * speed * 0.35 + Math.sin(tangentialAngle) * speed * 0.65;
      }
      
      function resetParticle(p) {
        // Spawn particles from all four sides for constant stream
        const spawnSide = Math.floor(Math.random() * 4); // 0=left, 1=right, 2=top, 3=bottom
        
        let spawnX, spawnY;
        
        if (spawnSide === 0) {
          // Left side
          spawnX = -(width * 0.45 + Math.random() * width * 0.1);
          spawnY = (Math.random() - 0.5) * height * 0.6;
        } else if (spawnSide === 1) {
          // Right side
          spawnX = (width * 0.45 + Math.random() * width * 0.1);
          spawnY = (Math.random() - 0.5) * height * 0.6;
        } else if (spawnSide === 2) {
          // Top
          spawnX = (Math.random() - 0.5) * width * 0.6;
          spawnY = -(height * 0.45 + Math.random() * height * 0.1);
        } else {
          // Bottom
          spawnX = (Math.random() - 0.5) * width * 0.6;
          spawnY = (height * 0.45 + Math.random() * height * 0.1);
        }
        
        p.x = spawnX;
        p.y = spawnY;
        
        p.z = randomBetween(0.5, 1.5);
        p.size = randomBetween(0.5, 1.5);
        p.opacity = randomBetween(0.3, 0.8);
        p.speed = randomBetween(0.0002, 0.0008);
        p.twinkle = randomBetween(0, 1);
        p.twinkleSpeed = randomBetween(0.01, 0.04);
        
        // Blue/white colors to match home screen theme
        const colorChoice = Math.random();
        if (colorChoice < 0.4) {
          p.color = '#4fc3f7'; // Bright blue (primary)
        } else if (colorChoice < 0.7) {
          p.color = '#ffffff'; // White
        } else if (colorChoice < 0.85) {
          p.color = '#81d4fa'; // Light blue
        } else {
          p.color = '#b3e5fc'; // Very light blue
        }
        
        // Initial velocity: move toward center with spiral
        const distance = Math.sqrt(p.x * p.x + p.y * p.y);
        const speed = randomBetween(0.3, 0.6);
        
        // Direction toward center
        const angleToCenter = Math.atan2(-p.y, -p.x);
        
        // Add tangential component for immediate spiral (perpendicular to inward)
        const tangentialAngle = angleToCenter + Math.PI / 2;
        
        // Start with proper spiral motion: 35% inward, 65% tangential
        p.vx = Math.cos(angleToCenter) * speed * 0.35 + Math.cos(tangentialAngle) * speed * 0.65;
        p.vy = Math.sin(angleToCenter) * speed * 0.35 + Math.sin(tangentialAngle) * speed * 0.65;
      }
      
      // Initialize particles at various positions along their path for immediate animation
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const p = {};
        resetParticle(p);
        
        // Distribute some particles along their path (not all at the edge)
        // 60% of particles start mid-journey for immediate visual interest
        if (i < PARTICLE_COUNT * 0.6) {
          // Calculate progress along the spiral path (0.2 to 0.8 = 20% to 80% of journey)
          const progress = 0.2 + (Math.random() * 0.6);
          
          // Scale position to simulate progress toward center
          p.x *= (1 - progress * 0.7);
          p.y *= (1 - progress * 0.7);
          
          // Adjust velocity to match the current position in the spiral
          const distance = Math.sqrt(p.x * p.x + p.y * p.y);
          const currentSpeed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          const angleToCenter = Math.atan2(-p.y, -p.x);
          const tangentialAngle = angleToCenter + Math.PI / 2;
          
          // Recalculate velocity based on new position to maintain spiral
          p.vx = Math.cos(angleToCenter) * currentSpeed * 0.35 + Math.cos(tangentialAngle) * currentSpeed * 0.65;
          p.vy = Math.sin(angleToCenter) * currentSpeed * 0.35 + Math.sin(tangentialAngle) * currentSpeed * 0.65;
        }
        
        particles.push(p);
      }
      
      // Initialize code bubbles with varied positions for natural look
      for (let i = 0; i < CODE_BUBBLE_COUNT; i++) {
        const bubble = {};
        resetCodeBubble(bubble, i);
        
        // Distribute 50% of bubbles along their path
        if (i < CODE_BUBBLE_COUNT * 0.5) {
          const progress = 0.3 + (Math.random() * 0.5);
          bubble.x *= (1 - progress * 0.6);
          bubble.y *= (1 - progress * 0.6);
          
          // Recalculate velocity
          const currentSpeed = Math.sqrt(bubble.vx * bubble.vx + bubble.vy * bubble.vy);
          const angleToCenter = Math.atan2(-bubble.y, -bubble.x);
          const tangentialAngle = angleToCenter + Math.PI / 2;
          
          bubble.vx = Math.cos(angleToCenter) * currentSpeed * 0.35 + Math.cos(tangentialAngle) * currentSpeed * 0.65;
          bubble.vy = Math.sin(angleToCenter) * currentSpeed * 0.35 + Math.sin(tangentialAngle) * currentSpeed * 0.65;
        }
        
        codeBubbles.push(bubble);
      }
      
      function isPointInOval(px, py, ox, oy, rx, ry) {
        const dx = px - ox;
        const dy = py - oy;
        return (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) <= 1;
      }
      
      function applyGravityWell(p) {
        // Get particle's current screen position
        const screenX = cx + p.x;
        const screenY = cy + p.y;
        
        // Calculate distance to black hole center
        const dx = gravityWell.x - screenX;
        const dy = gravityWell.y - screenY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Apply gentle knowledge absorption effect
        const maxDistance = Math.max(width, height) * 0.6;
        
        if (distance > 0 && distance < maxDistance) {
          // Maintain constant speed while creating spiral effect
          const currentSpeed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          
          // Calculate direction FROM particle TO black hole
          const angleToBlackHole = Math.atan2(dy, dx);
          
          // Create spiral by combining inward and tangential motion
          // Tangential (perpendicular to inward) for circular motion
          const tangentialAngle = angleToBlackHole + Math.PI / 2;
          
          // Spiral effect: balanced for half-circle spiral
          const spiralInward = 0.35; // 35% inward for tighter spiral
          const spiralTangential = 0.65; // 65% circular
          
          const targetVx = Math.cos(angleToBlackHole) * currentSpeed * spiralInward + 
                          Math.cos(tangentialAngle) * currentSpeed * spiralTangential;
          const targetVy = Math.sin(angleToBlackHole) * currentSpeed * spiralInward + 
                          Math.sin(tangentialAngle) * currentSpeed * spiralTangential;
          
          // Smoothly blend current velocity with spiral target
          p.vx = p.vx * 0.95 + targetVx * 0.05;
          p.vy = p.vy * 0.95 + targetVy * 0.05;
          
          // Normalize to maintain constant speed
          const newSpeed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          if (newSpeed > 0) {
            p.vx = (p.vx / newSpeed) * currentSpeed;
            p.vy = (p.vy / newSpeed) * currentSpeed;
          }
          
          // Check if particle hits oval - just delete it silently
          if (isPointInOval(screenX, screenY, gravityWell.x, gravityWell.y, 
                           gravityWell.eventHorizonX, gravityWell.eventHorizonY)) {
            resetParticle(p);
            return false; // Particle deleted
          }
        }
        
        return true; // Particle still learning
      }
      
      function draw() {
        ctx.clearRect(0, 0, width, height);
        
        // Gravity well is invisible now - no drawing
        
        // Update and draw particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          
          // Apply gravity well
          if (!applyGravityWell(p)) {
            continue; // Particle was destroyed
          }
          
          // Update particle position
          p.x += p.vx;
          p.y += p.vy;
          // Keep z constant to avoid perspective explosion
          // p.z -= p.speed;
          p.twinkle += p.twinkleSpeed;
          
          // Check bounds and reset if needed
          const screenX = cx + p.x;
          const screenY = cy + p.y;
          if (screenX < -50 || screenX > width + 50 || 
              screenY < -50 || screenY > height + 50) {
            resetParticle(p);
            continue;
          }
          
          // Perspective projection
          const perspective = 1 / p.z;
          const px = cx + p.x * perspective;
          const py = cy + p.y * perspective;
          const scale = (0.4 + (2 / p.z)) * p.size;
          
          // Twinkling effect
          const twinkleAlpha = 0.3 + 0.7 * Math.sin(p.twinkle);
          const finalAlpha = p.opacity * (1.6 - p.z) * twinkleAlpha;
          
          // Draw particle trail (knowledge trails)
          const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          
          if (speed > 0.1) {
            // Draw knowledge trail
            ctx.globalAlpha = finalAlpha * 0.2;
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px - p.vx * 5, py - p.vy * 5);
            ctx.strokeStyle = p.color;
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
          
          // Draw particle
          ctx.globalAlpha = Math.max(0, Math.min(1, finalAlpha));
          ctx.beginPath();
          ctx.arc(px, py, scale, 0, 2 * Math.PI);
          ctx.fillStyle = p.color;
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 10 * (1.6 - p.z) * twinkleAlpha;
          ctx.fill();
          ctx.shadowBlur = 0;
          
          // Add glow effect for brighter particles
          if (p.opacity > 0.4 && scale > 1.2) {
            ctx.globalAlpha = finalAlpha * 0.2;
            ctx.beginPath();
            ctx.arc(px, py, scale * 2, 0, 2 * Math.PI);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
        }
        
        // No destroyed particle effects - removed
        
        // Update and draw code bubbles
        for (let i = codeBubbles.length - 1; i >= 0; i--) {
          const bubble = codeBubbles[i];
          
          // Apply same gravity well logic as particles
          const screenX = cx + bubble.x;
          const screenY = cy + bubble.y;
          const dx = gravityWell.x - screenX;
          const dy = gravityWell.y - screenY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const maxDistance = Math.max(width, height) * 0.6;
          
          if (distance > 0 && distance < maxDistance) {
            const currentSpeed = Math.sqrt(bubble.vx * bubble.vx + bubble.vy * bubble.vy);
            const angleToBlackHole = Math.atan2(dy, dx);
            const tangentialAngle = angleToBlackHole + Math.PI / 2;
            const spiralInward = 0.35;
            const spiralTangential = 0.65;
            
            const targetVx = Math.cos(angleToBlackHole) * currentSpeed * spiralInward + 
                            Math.cos(tangentialAngle) * currentSpeed * spiralTangential;
            const targetVy = Math.sin(angleToBlackHole) * currentSpeed * spiralInward + 
                            Math.sin(tangentialAngle) * currentSpeed * spiralTangential;
            
            bubble.vx = bubble.vx * 0.95 + targetVx * 0.05;
            bubble.vy = bubble.vy * 0.95 + targetVy * 0.05;
            
            const newSpeed = Math.sqrt(bubble.vx * bubble.vx + bubble.vy * bubble.vy);
            if (newSpeed > 0) {
              bubble.vx = (bubble.vx / newSpeed) * currentSpeed;
              bubble.vy = (bubble.vy / newSpeed) * currentSpeed;
            }
            
            // Check if bubble hits gravity well
            if (isPointInOval(screenX, screenY, gravityWell.x, gravityWell.y, 
                             gravityWell.eventHorizonX, gravityWell.eventHorizonY)) {
              resetCodeBubble(bubble, i);
            continue;
            }
          }
          
          // Update position
          bubble.x += bubble.vx;
          bubble.y += bubble.vy;
          
          // Check bounds
          if (screenX < -100 || screenX > width + 100 || 
              screenY < -100 || screenY > height + 100) {
            resetCodeBubble(bubble, i);
            continue;
          }
          
          // Draw bubble
          const perspective = 1 / bubble.z;
          const bx = cx + bubble.x * perspective;
          const by = cy + bubble.y * perspective;
          const bubbleRadius = bubble.size * perspective;
          
          // Draw bubble circle with glass effect - very subtle
          ctx.globalAlpha = bubble.opacity * 0.2;
          ctx.fillStyle = 'rgba(79, 195, 247, 0.1)';
          ctx.beginPath();
          ctx.arc(bx, by, bubbleRadius, 0, 2 * Math.PI);
          ctx.fill();
          
          // Draw bubble border - subtle
          ctx.globalAlpha = bubble.opacity * 0.4;
          ctx.strokeStyle = '#4fc3f7';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(bx, by, bubbleRadius, 0, 2 * Math.PI);
          ctx.stroke();
          
          // Draw text inside bubble - more faded
          ctx.globalAlpha = bubble.opacity * 0.8;
          ctx.fillStyle = '#ffffff';
          ctx.font = `${Math.floor(bubbleRadius * 0.6)}px 'Inter', monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(bubble.text, bx, by);
        }
        
        ctx.globalAlpha = 1;
        requestAnimationFrame(draw);
      }
      
      draw();
    })();

    // Trigger wave animation: 3.5s animation, 6s pause
    function triggerWave() {
      const wave = document.querySelector('.wave-text');
      if (!wave) return;
      wave.classList.remove('wave-animate');
      void wave.offsetWidth;
      wave.classList.add('wave-animate');
      // Wait for animation to complete (3.5s) plus 6s pause before next wave
      setTimeout(triggerWave, 9500);
    }
    // Start the wave animation after 6 seconds
    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(triggerWave, 6000);
    });

    function extractSection(html, section) {
      // Extracts the section content from the longDesc HTML string
      const regex = new RegExp(`<b>${section}<\\/b>\\s*([^<]*)`, 'i');
      const match = html.match(regex);
      return match ? match[1].trim() : '';
    }

    // Glitch effect for subtitle with cycling phrases
    (function() {
      const subtitleElement = document.getElementById('typing-subtitle');
      if (!subtitleElement) return;

      const phrases = [
        'COMPUTER SCIENCE STUDENT | FULL STACK DEVELOPER.',
        'READY TO INNOVATE.',
        'READY TO COLLABORATE.',
        'READY TO BUILD THE FUTURE.'
      ];

      let currentPhraseIndex = 0;
      let letterElements = [];
      let lineWrapper = null;

      function createLetterSpans(text) {
        subtitleElement.innerHTML = '';
        letterElements = [];
        
        // Create a wrapper for the entire line
        lineWrapper = document.createElement('div');
        lineWrapper.style.display = 'inline-flex';
        lineWrapper.style.gap = '0';
        
        // Create letter spans for mouseover effect
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const span = document.createElement('span');
          
          if (char === ' ') {
            span.innerHTML = '&nbsp;';
            span.classList.add('mx-1');
          } else {
            span.textContent = char;
          }
          
          span.style.display = 'inline-block';
          span.style.transition = 'transform 0.2s ease-out';
          lineWrapper.appendChild(span);
          letterElements.push(span);
        }
        
        subtitleElement.appendChild(lineWrapper);
      }

      function glitchInPhrase() {
        const currentPhrase = phrases[currentPhraseIndex];
        createLetterSpans(currentPhrase);
        
        // Trigger glitch in animation
        lineWrapper.classList.add('glitch-in');
        
        // After display time, glitch out and move to next phrase
        setTimeout(() => {
          glitchOutPhrase();
        }, 3500); // Display for 3.5 seconds
      }

      function glitchOutPhrase() {
        lineWrapper.classList.remove('glitch-in');
        lineWrapper.classList.add('glitch-out');
        
        // After glitch out completes, show next phrase
        setTimeout(() => {
          currentPhraseIndex = (currentPhraseIndex + 1) % phrases.length;
          glitchInPhrase();
        }, 300); // Match glitchOut animation duration
      }

      // Mouse-over effect for letters
      document.addEventListener('mousemove', (e) => {
        letterElements.forEach(letter => {
          const rect = letter.getBoundingClientRect();
          const letterX = rect.left + rect.width / 2;
          const letterY = rect.top + rect.height / 2;

          const distX = e.clientX - letterX;
          const distY = e.clientY - letterY;
          const distance = Math.sqrt(distX ** 2 + distY ** 2);
          
          if (distance < 80) {
            const angle = Math.atan2(distY, distX);
            const offset = (80 - distance) / 3;
            letter.style.transform = `translate(${-Math.cos(angle) * offset}px, ${-Math.sin(angle) * offset}px)`;
          } else {
            letter.style.transform = 'translate(0, 0)';
          }
        });
      });

      // Wait for name to finish typing, then start subtitle
      function startSubtitleWhenReady() {
        if (subtitleReady) {
          setTimeout(glitchInPhrase, 500); // Start subtitle 500ms after name completes
        } else {
          setTimeout(startSubtitleWhenReady, 100); // Check again in 100ms
        }
      }
      
      startSubtitleWhenReady();
    })();

    </script>
  </body>
</html>